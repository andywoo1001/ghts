package internal

import (
	"runtime"
	"testing"
	"time"
)

func TestF외부_프로세스_관리_Go루틴(테스트 *testing.T) {
	// 시작 이전에 실행되고 있는 외부 프로세스 모두 정리
	f외부_프로세스_정리_by_파일()

	// 테스트용 채널 초기화
	Ch외부_프로세스_정상종료_테스트용 = make(chan S비어있는_구조체, 1000)
	Ch정리된_프로세스_수량_by_맵 = make(chan int, 1000)
	Ch정리된_프로세스_수량_by_파일 = make(chan int, 1000)
	
	// 테스트 종료 후 테스트용 채널 없애기
	defer func() {
		Ch외부_프로세스_정상종료_테스트용 = nil
		Ch정리된_프로세스_수량_by_맵 = nil
		Ch정리된_프로세스_수량_by_파일 = nil
	}()
	
	// 멀티 스레드 모드로 전환
	if runtime.GOMAXPROCS(-1) == 1 {
		runtime.GOMAXPROCS(runtime.NumCPU())
		
		defer runtime.GOMAXPROCS(1)
	}		
	
	// 준비를 마치고 실제 테스트 시작
	// 1. 타임아웃 전에 종료되는 프로세스 : 대기시간 < 타임아웃
	// 2. 타임아웃을 1초 이상 넘기고 종료되는 프로세스 : 대기시간 > 타임아웃 + 1초
	// 3. Go루틴 종료될 때까지 남아있다가 종료되는 프로세스 : 타임아웃 > 종료신호 보낼 때까지의 시간.
	const 정상_종료_프로세스_수량 = 3
	const 타임아웃_프로세스_수량 = 4
	const 끝까지_남는_프로세스_수량 = 5
	
	
	const 정상_종료_타임아웃 = 500 * time.Millisecond	// 0.5초
	const 정상_종료_대기시간 = 0.0001	// 파이썬은 time.sleep() 대기시간 단위가 '초'임.
	
	const 중간_정리_타임아웃 = 500 * time.Millisecond	// 0.5초 
	const 중간_정리_대기시간 = 1.6
	
	const 끝까지_남는_타임아웃 = 60 * time.Second
	const 끝까지_남는_대기시간 = 60
	
	에러_반환_채널 := make(chan error, 100)
	
	// 외부 프로세스 생성
	for i:=0 ; i < 정상_종료_프로세스_수량; i++ {
		F파이썬_스크립트_실행(에러_반환_채널, 정상_종료_타임아웃, "func_external_process_test.py", 정상_종료_대기시간) 
	}
	
	for i:=0 ; i < 타임아웃_프로세스_수량; i++ {
		F파이썬_스크립트_실행(에러_반환_채널, 중간_정리_타임아웃, "func_external_process_test.py", 중간_정리_대기시간) 
	}
	
	for i:=0 ; i < 끝까지_남는_프로세스_수량; i++ {
		F파이썬_스크립트_실행(에러_반환_채널, 끝까지_남는_타임아웃, "func_external_process_test.py", 끝까지_남는_대기시간) 
	}
	
	총수량 := 정상_종료_프로세스_수량 + 타임아웃_프로세스_수량 + 끝까지_남는_프로세스_수량 
	
	for i:=0 ; i < 총수량 ; i++ {
		에러 := <-에러_반환_채널
		F테스트_에러없음(테스트, 에러) 
	}
	
	누적_정상_종료_프로세스_수량 := 0
	누적_정리된_프로세스_수량_by_맵 := 0
	누적_정리된_프로세스_수량_by_파일 := 0
	
	대기_시작_시점 := time.Now()
	
	반복문1:
		for {
			select {
			case <-Ch외부_프로세스_정상종료_테스트용:
				누적_정상_종료_프로세스_수량++
			case 수량 := <-Ch정리된_프로세스_수량_by_맵:
				누적_정리된_프로세스_수량_by_맵 += 수량
			default:
				if time.Since(대기_시작_시점) > 5 * time.Second {
					break 반복문1
				}
				
				누적_수량 := 누적_정상_종료_프로세스_수량 + 
								누적_정리된_프로세스_수량_by_맵
								
				if 누적_수량 == 정상_종료_프로세스_수량 + 타임아웃_프로세스_수량 {
					break 반복문1
				}
				
				time.Sleep(300 * time.Millisecond)
			}
		}
	
	f외부_프로세스_정리_by_파일()
		
	대기_시작_시점 = time.Now()
	
	반복문2:
		for {
			select {
			case 수량 := <-Ch정리된_프로세스_수량_by_파일:
				누적_정리된_프로세스_수량_by_파일 += 수량
			default:
				if time.Since(대기_시작_시점) > 5 * time.Second {
					break 반복문2
				}
				
				if 누적_정리된_프로세스_수량_by_파일 == 끝까지_남는_프로세스_수량 {
					break 반복문2
				}
			}
		}
			
		
	F테스트_같음(테스트, 누적_정상_종료_프로세스_수량, 정상_종료_프로세스_수량)
	F테스트_같음(테스트, 누적_정리된_프로세스_수량_by_맵, 타임아웃_프로세스_수량)
	F테스트_같음(테스트, 누적_정리된_프로세스_수량_by_파일, 끝까지_남는_프로세스_수량)
}