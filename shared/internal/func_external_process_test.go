package internal

import (
	"runtime"
	"testing"
	"time"
)

func TestF외부_프로세스_관리_Go루틴(테스트 *testing.T) {
	F메모("\n에러가 난 원인을 모를 때는 테스트를 단순하게 만들어서 분석하기 쉽게 만든 후, \n" +
			"실행 과정을 하나, 하나 출력해 보면서 내부 흐름 추적하자.\n" +
			"그보다 별 달리 더 좋은 방법이 있을까나?\n\n")
	// 멀티 스레드 모드로 전환
	if runtime.GOMAXPROCS(-1) == 1 {
		runtime.GOMAXPROCS(runtime.NumCPU())
		
		defer runtime.GOMAXPROCS(1)
	}
	
	// 공통 종료 채널을 이용하는 다른 테스트에 영향을 주지 않기 위해서
	// 새로운 채널을 이용해서 테스트를 진행함.
	// 테스트 종료할 때는 원래대로 되돌려 놓음.
	ch공통_종료_채널_원본 := ch공통_종료_채널
	ch공통_종료_채널 = make(chan S비어있는_구조체)
	
	defer func() {
		ch공통_종료_채널 = ch공통_종료_채널_원본 
	}()
	
	// 준비
	go F외부_프로세스_관리_Go루틴()
	ch외부_프로세스_테스트용_채널_활성화 <- true
	defer func() {
		ch외부_프로세스_테스트용_채널_활성화 <- false
	}()
	
	// 시작 이전에 실행되고 있는 외부 프로세스 모두 정리
	f외부_프로세스_정리_by_파일()
	
	// 테스트용 채널 초기화
	Ch프로세스_정상_종료_테스트용 = make(chan int, 1000)
	Ch맵_기반_정리된_프로세스_수량_테스트용 = make(chan int, 1000)
	Ch파일_기반_정리된_프로세스_수량_테스트용 = make(chan int, 1000)
	
	defer func() {
		Ch프로세스_정상_종료_테스트용 = nil
		Ch맵_기반_정리된_프로세스_수량_테스트용 = nil
		Ch파일_기반_정리된_프로세스_수량_테스트용 = nil
	}()
	
	/* 준비를 마치고 실제 테스트 시작
	1. 정상적으로 종료되는 프로세스 : 대기시간 < 타임아웃
	2. 타임아웃으로 강제 종료되는 프로세스 : 대기시간 > 타임아웃 + 1초
	3. Go루틴이 종료될 때까지 끝까지 남아있다가 강제 종료되는 프로세스
		: 대기시간 > Go루틴에게 종료신호 보낼 때까지의 시간.
		: 타임아웃 > Go루틴에게 종료신호 보낼 때까지의 시간.
	*/
			
	
	// 디버깅 마친 후 사용할 정상값.
	//const 정상_종료_프로세스_수량 = 3
	//const 타임아웃_프로세스_수량 = 4
	//const 끝까지_남는_프로세스_수량 = 5
	
	// 디버깅을 위해서 단순화 한 값.
	const 정상_종료_프로세스_수량 = 10
	const 타임아웃_프로세스_수량 = 0
	const 끝까지_남는_프로세스_수량 = 0
	
	const 총_프로세스_수량 = 정상_종료_프로세스_수량 + 타임아웃_프로세스_수량 + 끝까지_남는_프로세스_수량  
	
	const 정상_종료_타임아웃 = 500 * time.Millisecond	// 0.5초
	const 정상_종료_대기시간 = 0.0001	// 파이썬은 time.sleep() 대기시간 단위가 '초'임.
	
	const 강제_종료_타임아웃 = 500 * time.Millisecond	// 0.5초 
	const 강제_종료_대기시간 = 1.6
	
	const 끝까지_남는_타임아웃 = 1000 * time.Second
	const 끝까지_남는_대기시간 = 1000
	
	const go루틴_소프트_타임아웃 = 5 * time.Second
	const go루틴_하드_타임아웃 = 10 * time.Second
	
	에러_반환_채널 := make(chan error, 100)
	
	//F문자열_출력("5")
	
	// 외부 프로세스 생성
	for i:=0 ; i < 정상_종료_프로세스_수량; i++ {
		//F문자열_출력("5-%v", i)
		F파이썬_스크립트_실행(에러_반환_채널, 정상_종료_타임아웃, "func_external_process_test.py", 정상_종료_대기시간) 
	}
	
	//F문자열_출력("6")
	
	for i:=0 ; i < 타임아웃_프로세스_수량; i++ {
		//F문자열_출력("6-%v", i)
		F파이썬_스크립트_실행(에러_반환_채널, 강제_종료_타임아웃, "func_external_process_test.py", 강제_종료_대기시간) 
	}
	
	//F문자열_출력("7")
	
	for i:=0 ; i < 끝까지_남는_프로세스_수량; i++ {
		//F문자열_출력("7-%v", i)
		F파이썬_스크립트_실행(에러_반환_채널, 끝까지_남는_타임아웃, "func_external_process_test.py", 끝까지_남는_대기시간) 
	}
	
	//F문자열_출력("8")
	
	for i:=0 ; i < 총_프로세스_수량 ; i++ {
		//F문자열_출력("8-%v", i)
		에러 := <-에러_반환_채널
		F테스트_에러없음(테스트, 에러) 
	}
	
	대기_시작_시점 := time.Now()
	
	/*
	//이건 별로 안 좋은 방식
	for {
		if time.Since(대기_시작_시점) > 5 * time.Second {
			F문자열_출력("테스트 반복문 타임아웃.")
			break
		}
		
		합계 := 관리_루틴_외부_프로세스_정상_종료_수량 +
				관리_루틴_외부_프로세스_강제_종료_by_맵_수량 +
				관리_루틴_외부_프로세스_강제_종료_by_파일_수량
				
		if 합계 == 총_프로세스_수량 {
			F문자열_출력("테스트 반복문 정상 종료")
			break
		}
		
		time.Sleep(300 * time.Millisecond)
	}
	
	F문자열_출력("테스트 반복문 종료 : 정상 종료 %v, 강제 종료 %v, 합계 %v\n",
					 			관리_루틴_외부_프로세스_정상_종료_수량,
					 			관리_루틴_외부_프로세스_강제_종료_by_맵_수량,
					 			관리_루틴_외부_프로세스_정상_종료_수량 + 관리_루틴_외부_프로세스_강제_종료_by_맵_수량)
	
	F테스트_같음(테스트, 
		관리_루틴_외부_프로세스_정상_종료_수량 +
		관리_루틴_외부_프로세스_강제_종료_by_맵_수량, 
		정상_종료_프로세스_수량 + 타임아웃_프로세스_수량)
	
	F테스트_같음(테스트, 
		관리_루틴_외부_프로세스_정상_종료_수량, 
		정상_종료_프로세스_수량)
	
	F테스트_같음(테스트, 
		관리_루틴_외부_프로세스_강제_종료_by_맵_수량, 
		타임아웃_프로세스_수량)
	*/
	
	// 이게 바람직한 방식.
	누적_정상_종료_프로세스_수량 := 0
	누적_정리된_프로세스_수량_by_맵 := 0
	누적_정리된_프로세스_수량_by_파일 := 0
	소프트_타임아웃_됨 := false
	
	반복문:
		for {
			select {
			//case pid := <-Ch프로세스_정상_종료_테스트용:
			case <-Ch프로세스_정상_종료_테스트용:
				누적_정상_종료_프로세스_수량++
				//F문자열_출력("PID %v : 테스트. 정상 종료 신호 '수신'. 누적 %v", pid, 누적_정상_종료_프로세스_수량)
			case 수량 := <-Ch맵_기반_정리된_프로세스_수량_테스트용:
				누적_정리된_프로세스_수량_by_맵 += 수량
				F문자열_출력("테스트. 맵 기반 강제 종료 신호 '수신' . 수량 %v, 누적 %v", 수량, 누적_정리된_프로세스_수량_by_맵)
			case 수량 := <-Ch파일_기반_정리된_프로세스_수량_테스트용:
				누적_정리된_프로세스_수량_by_파일 += 수량
				F문자열_출력("테스트. 파일 기반 강제 종료 신호 '수신' . 수량 %v, 누적 %v", 수량, 누적_정리된_프로세스_수량_by_파일)
			default:
				switch {
				case !소프트_타임아웃_됨 && 
					time.Since(대기_시작_시점) > go루틴_소프트_타임아웃:
					
					if  { break }
					 
					ch공통_종료_채널 <- S비어있는_구조체{}
					소프트_타임아웃_됨 = true
					
					F문자열_출력("테스트 반복문 소프트 타임아웃.")
				case time.Since(대기_시작_시점) > go루틴_하드_타임아웃:
					F문자열_출력("테스트 반복문 하드 타임아웃. break")
					break 반복문
				default:
					합계 := 누적_정상_종료_프로세스_수량 + 
						누적_정리된_프로세스_수량_by_맵 + 
						누적_정리된_프로세스_수량_by_파일
				
					if 합계 == 총_프로세스_수량 {
						F문자열_출력("테스트 반복문 정상 종료")
						break 반복문
					}
				}
				
				time.Sleep(200 * time.Millisecond)
			}
		}
		
	F문자열_출력("반복문 종료 : 정상 종료 %v, 맵 종료 %v, 파일 종료 %v, 합계 %v, 예상 총수량 %v",
					 			누적_정상_종료_프로세스_수량,
					 			누적_정리된_프로세스_수량_by_맵,
					 			누적_정리된_프로세스_수량_by_파일,
					 			누적_정상_종료_프로세스_수량 + 
					 			누적_정리된_프로세스_수량_by_맵 + 
					 			누적_정리된_프로세스_수량_by_파일,
					 			총_프로세스_수량)
		
	F테스트_같음(테스트, 총_프로세스_수량,
						누적_정상_종료_프로세스_수량 + 
						누적_정리된_프로세스_수량_by_맵 + 
						누적_정리된_프로세스_수량_by_파일)
	
	F테스트_같음(테스트, 누적_정상_종료_프로세스_수량, 정상_종료_프로세스_수량)
	F테스트_같음(테스트, 누적_정리된_프로세스_수량_by_맵, 타임아웃_프로세스_수량)
	F테스트_같음(테스트, 누적_정리된_프로세스_수량_by_파일, 끝까지_남는_프로세스_수량)
}