package internal

import (
	"math/rand"
	"runtime"
	"testing"
	"time"
)

func TestF외부_프로세스_관리_Go루틴(테스트 *testing.T) {
	// 멀티 스레드 모드로 전환
	if runtime.GOMAXPROCS(-1) == 1 {
		runtime.GOMAXPROCS(runtime.NumCPU())
		
		defer runtime.GOMAXPROCS(1)
	}
	
	// 랜덤값 생성기
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	
	f외부_프로세스_관리_Go루틴_테스트_도우미(테스트, r.Intn(10), r.Intn(10), r.Intn(10))
}

const p정상_종료_타임아웃 = 500 * time.Millisecond	// 0.5초
const p정상_종료_대기시간 = 0.0001	// 파이썬은 time.sleep() 대기시간 단위가 '초'임.

const p강제_종료_타임아웃 = time.Second	// 1초 
const p강제_종료_대기시간 = 2.1

const p끝까지_남는_타임아웃 = 1000 * time.Second // 충분히 긴 시간
const p끝까지_남는_대기시간 = 1000

const p_Go루틴_소프트_타임아웃 = 5 * time.Second
const p_Go루틴_하드_타임아웃 = 10 * time.Second

func f외부_프로세스_관리_Go루틴_테스트_도우미(테스트 *testing.T, 
		정상_종료_프로세스_수량, 강제_종료_프로세스_수량, 끝까지_남는_프로세스_수량 int) {
	F외부_프로세스_관리_Go루틴_종료()
	
	// Go루틴 준비	
	ch새로운_Go루틴_실행_성공 := make(chan bool)
	go F외부_프로세스_관리_Go루틴(ch새로운_Go루틴_실행_성공)
	F테스트_참임(테스트, <-ch새로운_Go루틴_실행_성공)
	
	ch외부_프로세스_테스트용_채널_활성화 <- true
	
	에러_회신_채널 := make(chan error, 100)
	
	// 외부 프로세스 생성
	for i:=0 ; i < 정상_종료_프로세스_수량; i++ {
		F파이썬_스크립트_실행(에러_회신_채널, p정상_종료_타임아웃, "func_external_process_test.py", p정상_종료_대기시간) 
	}
	
	for i:=0 ; i < 강제_종료_프로세스_수량; i++ {
		F파이썬_스크립트_실행(에러_회신_채널, p강제_종료_타임아웃, "func_external_process_test.py", p강제_종료_대기시간) 
	}
	
	for i:=0 ; i < 끝까지_남는_프로세스_수량; i++ {
		F파이썬_스크립트_실행(에러_회신_채널, p끝까지_남는_타임아웃, "func_external_process_test.py", p끝까지_남는_대기시간) 
	}
	
	총_프로세스_수량 := 정상_종료_프로세스_수량 + 강제_종료_프로세스_수량 + 끝까지_남는_프로세스_수량
	for i:=0 ; i < 총_프로세스_수량 ; i++ {
		에러 := <-에러_회신_채널
		F테스트_에러없음(테스트, 에러) 
	}
	
	// 외부 프로세스 Go루틴 모니터링
	누적_정상_종료_수량 := 0
	누적_강제_종료_수량 := 0
	누적_정리된_프로세스_수량_by_파일 := 0
	소프트_타임아웃_됨 := false
	대기_시작_시점 := time.Now()
		
반복문:		
		for {		
			select {
			case <-ch프로세스_정상_종료_테스트용:
				누적_정상_종료_수량++
				
				if 누적_정상_종료_수량 + 누적_강제_종료_수량 ==  정상_종료_프로세스_수량 + 강제_종료_프로세스_수량 {
					// 외부 프로세스 관리 Go루틴 종료할 조건 만족
					종료, 수량 := F외부_프로세스_관리_Go루틴_종료()
					F테스트_참임(테스트, 종료)
					
					누적_정리된_프로세스_수량_by_파일 += 수량
					
					break 반복문
				}
			case 수량 := <-ch프로세스_강제_종료_테스트용:
				누적_강제_종료_수량 += 수량
				
				if 누적_정상_종료_수량 + 누적_강제_종료_수량 ==  정상_종료_프로세스_수량 + 강제_종료_프로세스_수량 {
					// 외부 프로세스 관리 Go루틴 종료할 조건 만족
					종료, 수량 := F외부_프로세스_관리_Go루틴_종료()
					F테스트_참임(테스트, 종료)
					
					누적_정리된_프로세스_수량_by_파일 += 수량
					
					break 반복문
				}
			default:
				switch {
				case !소프트_타임아웃_됨 && 
					time.Since(대기_시작_시점) > p_Go루틴_소프트_타임아웃:
					 
					종료, 수량 := F외부_프로세스_관리_Go루틴_종료()
					F테스트_참임(테스트, 종료)
					
					누적_정리된_프로세스_수량_by_파일 += 수량
					
					소프트_타임아웃_됨 = true
				case time.Since(대기_시작_시점) > p_Go루틴_하드_타임아웃:
					break 반복문
				default:	
					합계 := 누적_정상_종료_수량 + 
						누적_강제_종료_수량 + 
						누적_정리된_프로세스_수량_by_파일
				
					if 합계 == 총_프로세스_수량 {
						break 반복문
					}
				}
				
				time.Sleep(500 * time.Millisecond)
			}
		}
		
	//F문자열_출력("정상 종료 %v, 맵 종료 %v, 파일 종료 %v, 합계 %v, 예상 총수량 %v",
	//			누적_정상_종료_수량,
	//			누적_강제_종료_수량,
	//			누적_정리된_프로세스_수량_by_파일,
	//			누적_정상_종료_수량 + 
	//			누적_강제_종료_수량 + 
	//			누적_정리된_프로세스_수량_by_파일,
	//			총_프로세스_수량)
		
	F테스트_같음(테스트, 누적_정상_종료_수량 + 누적_강제_종료_수량 + 누적_정리된_프로세스_수량_by_파일,  총_프로세스_수량)
	F테스트_같음(테스트, 누적_정리된_프로세스_수량_by_파일, 끝까지_남는_프로세스_수량)
	F테스트_같음(테스트, 누적_정상_종료_수량 + 누적_강제_종료_수량, 정상_종료_프로세스_수량 + 강제_종료_프로세스_수량)
}