package price_data

import (
	공용 "github.com/ghts/ghts/shared"
	
	"math"
	"strconv"
	"time"
)

var Ch가격정보 = make(chan 공용.I질의, 1000)
var Ch가격정보_구독_채널 = make(chan (chan 공용.I가격정보), 100)
var Ch가격정보_구독_소켓 = make(chan S구독소켓_등록, 100)
var ch종료_가격정보_Go루틴 = make(chan 공용.S비어있는_구조체)
var 가격정보_Go루틴_실행_중 = 공용.New안전한_bool(false)

func F가격정보_Go루틴_실행_중() bool {
	return 가격정보_Go루틴_실행_중.G값()
}

// 가격정보에 관련된 모든 기능의 허브
// - 가격정보 캐시 : 증권사 서버로 보내는 질의 수량 최소화 및 성능 향상.
// - 가격정보 질의 응답 : 가격정보 질의 응답 (캐시 데이터 확인 및 새로운 데이터 입수)
// - 가격정보 수신 : 가격정보 입수 기능이 가격정보를 PUSH할 경우 이를 캐시 데이터에 저장하고, 배포. 
// - 가격정보 배포 : 질의 응답 및 수신 과정에서 새로운 가격정보를 입수하게 되면 이를 배포함.
//
// 추가 개발이 필요한 기능
// - 가격정보 입수 : 증권사 서버에서 가격을 수신하는 기능

func F가격정보_Go루틴(ch초기화 chan bool) {
	// 이미 실행 중인 가격정보_Go루틴이 존재하는 지 확인
	에러 := 가격정보_Go루틴_실행_중.S값(true)
	if 에러 != nil {
		ch초기화 <- false; return
	}
	
	// zmq소켓을 통해서 가격정보 배포하는 Go루틴 실행.
	초기화_대기 := make(chan bool)
	go f_zmq소켓_가격정보_배포_Go루틴(초기화_대기)
	<-초기화_대기
	
	defer func() {
		ch종료_zmq소켓_가격정보_배포_Go루틴 <- 공용.S비어있는_구조체{}
		
		for zmq소켓_가격정보_배포_Go루틴_실행_중.G값() {
			time.Sleep(50 * time.Millisecond)
		}
	}()
	
	// 변수 초기화
	가격정보_맵 := make(map[string]공용.I가격정보)
	구독채널_맵 := make(map[chan 공용.I가격정보]공용.S비어있는_구조체)
	공통_종료_채널 := 공용.F공통_종료_채널()
	질의 := 공용.New질의(공용.P메시지_GET)	// GC 압력을 줄이기 위한 재활용 변수
	
	// 초기화 완료
	ch초기화 <- true
	
	for {
		select {
		case 질의 = <-Ch가격정보:	
			switch 질의.G구분() {
			case 공용.P메시지_GET:	
				가격정보, 에러 := f캐시된_가격정보_검색(질의, 가격정보_맵)
				
				// 에러가 발생하면 캐시된 데이터가 없다는 뜻이므로,
				// 에러가 발생해도 무시하고 다음 단계로 넘어간다.
				if 에러 == nil {
					f가격정보_회신_보내기(질의, 가격정보)
					break
				}
				
				공용.F메모("TODO : f새로운_가격정보_회신()")
				
				가격정보, 에러 = f새로운_가격정보_회신(질의, 가격정보_맵)
				if 에러 != nil {
					공용.F문자열_출력(질의.String())
					공용.F에러_출력(에러)
					질의.S회신(에러)
					break
				}
				
				f가격정보_회신_보내기(질의, 가격정보)
				
				에러 = f가격정보_배포(가격정보, 구독채널_맵)
				if 에러 != nil {
					공용.F문자열_출력(질의.String())
					공용.F에러_출력(에러)
				}
			case 공용.P메시지_SET:
				가격정보, 에러 := f가격정보_캐시_저장(질의, 가격정보_맵)
				
				if 에러 != nil {
					공용.F문자열_출력(질의.String())
					공용.F에러_출력(에러)
					질의.S회신(에러)
					break
				}
				
				질의.S회신(nil)
				
				에러 = f가격정보_배포(가격정보, 구독채널_맵)
				if 에러 != nil {
					공용.F문자열_출력(질의.String())
					공용.F에러_출력(에러)
				}
			default:
				질의.S회신(공용.F에러_생성("예상치 못한 메시지 구분.\n%v", 질의))
			}
		case ch구독 := <-Ch가격정보_구독_채널:
			구독채널_맵[ch구독] = 공용.S비어있는_구조체{}
		case <-공통_종료_채널:
			ch종료_가격정보_Go루틴 <- 공용.S비어있는_구조체{}
		case <-ch종료_가격정보_Go루틴:
			가격정보_Go루틴_실행_중.S값(false)
			return	
		}
	}
}

func f캐시된_가격정보_검색(질의 공용.I질의, 가격정보_맵 map[string]공용.I가격정보) (공용.I가격정보, error) {
	// 0 : 종목코드, 1 : 유효기간 (초 단위)
	if 에러 := 질의.G검사(공용.P메시지_GET, 2); 에러 != nil {
		return nil, 에러
	}
	
	초_단위_유효기간, 에러 := strconv.ParseFloat(질의.G내용(1), 64)
	if 에러 != nil {
		return nil, 에러
	}
	
	if 초_단위_유효기간 <= 0 {
		return nil, 공용.F에러_생성("유효기간이 0과 같거나 음수임. 가격정보 캐시 확인 중단.") 
	}
	
	종목코드 := 질의.G내용(0)
	가격정보, 존재함 := 가격정보_맵[종목코드]
	if !존재함 {
		에러 = 공용.F에러_생성("%v의 가격정보 캐시 데이터가 없음.\n%v", 종목코드, 질의)
		return nil, 에러
	}
		
	차이 := math.Abs(time.Now().Sub(가격정보.G시점()).Seconds())
		
	if 차이 > 초_단위_유효기간 {
		에러 = 공용.F에러_생성("유효기간이 지났음. 차이 %v초.", 차이)
		return nil, 에러
	}
	
	return 가격정보, nil
}

func f새로운_가격정보_회신(질의 공용.I질의, 가격정보_맵 map[string]공용.I가격정보) (공용.I가격정보, error) {
	return nil, 공용.F에러_생성("아직 구현하지 못함.")
}
	
func f가격정보_회신_보내기(질의 공용.I질의, 가격정보 공용.I가격정보) {
	질의.S회신(nil, 
		가격정보.G가격().G단위(), 
		가격정보.G가격().G문자열값(), 
		가격정보.G시점().Format(공용.P시간_형식))
}

func f가격정보_캐시_저장(질의 공용.I질의, 가격정보_맵 map[string]공용.I가격정보) (공용.I가격정보, error) {
	// 0 : 종목코드, 1 : 통화단위, 2 : 금액
	에러 := 질의.G검사(공용.P메시지_SET, 3)
	if 에러 != nil {
		return nil, 에러
	}
	
	에러 = 공용.F통화단위_검사(질의.G내용(1))
	if 에러 != nil {
		return nil, 에러
	}
	
	금액, 에러 := strconv.ParseFloat(질의.G내용(2), 64)
	if 에러 != nil {
		return nil, 에러
	}
		
	종목코드 := 질의.G내용(0)
	통화단위 := 질의.G내용(1)
	통화 := 공용.New통화(통화단위, 금액)
	
	if 통화 == nil {
		return nil, 공용.F에러_생성("통화 생성 에러.\n%v", 질의)
	}
	
	가격정보 := 공용.New가격정보(종목코드, 통화)
	
	가격정보_맵[종목코드] = 가격정보
	
	return 가격정보, nil
}

func f가격정보_배포(가격정보 공용.I가격정보, 
	구독채널_맵 map[chan 공용.I가격정보]공용.S비어있는_구조체) error {
	ch실행_결과 := make(chan error, 2)
	
	go f가격정보_배포_Go채널(ch실행_결과, 가격정보, 구독채널_맵)
	go f가격정보_배포_zmq소켓(ch실행_결과, 가격정보)
	
	에러_모음 := make([]error, 0)
	
	for i:=0 ; i < 2 ; i++ {
		에러 := <- ch실행_결과
		
		if 에러 != nil {
			공용.F문자열_출력("f가격정보_배포 4-%v 에러.\n%v", i, 에러)
			에러_모음 = append(에러_모음, 에러)
		}
	}
	
	if len(에러_모음) == 0 {
		return nil
	}
	에러_문자열 := ""
	
	for i:=0 ; i<len(에러_모음); i++ {
		에러_문자열 += 에러_모음[i].Error() + "\n"
	}
	
	return 공용.F에러_생성(에러_문자열)
}

func f가격정보_배포_Go채널(
		ch실행_결과 chan error,
		가격정보 공용.I가격정보,
		구독채널_맵 map[chan 공용.I가격정보]공용.S비어있는_구조체) {
	공용.F메모("개별 채널이 블록 되는 것을 대비해서 병렬로 처리하도록 할 것.")
	
	for ch구독, _ := range 구독채널_맵 {
		ch구독 <- 가격정보
	}
	
	ch실행_결과 <- nil
}
		
func f가격정보_배포_zmq소켓(
		ch실행_결과 chan error,
		가격정보 공용.I가격정보) {
	회신 := 공용.New질의(
					공용.P메시지_SET, 
					가격정보.G종목코드(),
					가격정보.G가격().G단위(), 
					가격정보.G가격().G문자열값(),
					가격정보.G시점().Format(공용.P시간_형식)).G회신(ch가격정보_배포_zmq소켓, 공용.P타임아웃_Go) 
	
	ch실행_결과 <- 회신.G에러()
}
		
func f가격정보_Go루틴_종료_후_재시작() {
	if F가격정보_Go루틴_실행_중() {
		ch종료_가격정보_Go루틴 <- 공용.S비어있는_구조체{}
	}
		
	for F가격정보_Go루틴_실행_중() {
		time.Sleep(100 * time.Millisecond)
	}
	
	초기화_대기 := make(chan bool)
	go F가격정보_Go루틴(초기화_대기)
	<-초기화_대기
}
