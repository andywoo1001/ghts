개략적인 구조.

다음에 나열된 모듈 간에 서로 메세지를 주고 받으면서 전체적인 매매 시스템을 구성한다.

1. 가격정보 모듈
2. 매매전략 모듈
3. 위험관리 모듈
4. 주문전송 모듈

그 외 공유되는 자료 모듈들. (독립된 모듈로 존재해야 함.)

1. 자산내역 모듈
2. 가격정보 캐쉬 모듈 
3. 주소정보 모듈
	- 각 모듈이 메세지를 주고 받는 endpoint 정보를 관리한다
	- 주소정보 모듈 그 자체의 endpoint는 다른 모든 모듈에게 미리 알려져야 한다. (고정 주소 사용.)
	- 매매전략 모듈 endpoint 모음
	- 위험관리 모듈 endpoint 모음
	- 가격정보 모듈 endpoint
	- 주문전송 모듈 endpoint
	- 자산내역 관리 모듈 endpoint
	- 가격정보 관리 모듈 endpoint

각 모듈은 고정된 bind endpoint를 가진 ROUTER서버와 임의의 connect endpoint를 가진 DEALER(or ROUTER) 클라이언트를 가진다.
	

Pub-Sub 패턴은 기술적으로 어려운 면이 있으므로,
대규모가 아닐 경우 ROUTER-DEALER패턴 (비동기화 된 Req-Res 패턴)을 반복하여 비슷한 효과를 꾀하자.


멀티스레드 모델의 경우 컴퓨팅 자원의 소모가 적은 장점이 있긴 하지만,
메모리 공유로 인해서 프로그래밍 상의 어려움이 너무 크므로,
최근의 풍부한 컴퓨팅 자원을 저렴하게 구입할 수 있는 상황을 고려하여,
컴퓨팅 자원의 소모가 약간 더 많기는 하지만,
메모리 공유가 원천적으로 차단되어서 프로그램의 안정성을 높이고,
프로그래밍의 단순함을 얻을 수 있는 '멀티 프로세스' 모델을 채택하기로 한다.

멀티스레드 모델에서 프로그래밍의 어려움에 대한 글은 다음을 참조한다.
Concurrency Hazards : 11 Likely Problems In Your Multithreaded Code
(동시처리의 위험성 : 멀티스레드 코드에서 발생하기 쉬운 11가지 문제점)
By Microsoft (마이크로소프트. MS 윈도우를 만든 소프트웨어 회사.)
링크 : https://msdn.microsoft.com/en-us/magazine/cc817398.aspx 

서로 간에 메모리가 독립된 프로세스 간에는 메세지 전달을 통해서 정보를 주고 받는다.
AMQP의 경우 세계 표준이고, 중앙집중식이라서 프로그래밍이 간편하지만,
고빈도 매매를 수행하기에는 성능이 떨어진다고 한다.
그리하여, ZeroMQ 혹은 그 후속작인 nanomsg를 기반으로 메세지를 서로 주고 받는다.
ZeroMQ와 nanomsg를 사용하면 독립된 프로세스 간에 메세지를 주고 받는 것 이외에도
서로 다른 프로그래밍 언어 간에 메세지를 주고 받을 수 있으며,
서로 다른 저작권을 따르는 소스 코드를 함께 사용할 수 있다는 장점도 있다.

서로 다른 프로그래밍 언어를 함께 사용하는 경우를 예를 들면, 
증권사의 API 사용법 예제가 C++로 되어 있는 반면에, 
매매전략 수립을 위한 통계계산 예제는 Python등으로 되어 있으며,
예제 소스코드를 최대한 재활용해서 매매 시스템을 구성하고 싶을 경우에,
C++로 되어 있는 예제와 Python으로 된 예제를 독립된 모듈로 만든 후
ZeroMQ나 nanomsg로 메세지를 주고 받으면서 매매 시스템을 구성하도록 하면 된다.

그 외에 서로 다른 라이센스를 가진 소스 코드의 경우 
하나의 프로그램에서 함께 사용하기 곤란한 경우가 있다.
예를 들면, GHTS는 상호협력을 유도하기 위하여 GPL V3를 따르는 데, 
GPL V3에 따르면 해당 소스코드를 다른 사람에게 판매하거나 배포할 경우에는
반드시 소스코드도 함께 배포해야 한다.
그러나, GHTS를 기반으로 하여서 자신만의 매매전략이나 위험관리 로직을 더하여서
타인에게 판매하고자 하는 경우가 있을 수 있다.
이럴 경우 매매전략, 위험관리 로직등 자신만의 비밀로 유지하지 싶은 부분은
별도의 모듈로 분리하고, GHTS와는 메세지를 주고 받으며 동작하게 한다면 해결된다.
이렇게 만든 시스템을 판매하거나 배포할 경우 기본 GHTS 소스코드만 공개하고,
자신만의 차별화된 매매전략등은 상업 라이센스를 적용하여 소스코드를 공개하지 않아도 된다.

GPL이 가지는 의미에 대해서 좀 더 자세한 기술적 설명.
GPL에 따르면 컴파일 및 빌드 중에 링크되는 소스코드에 대해서 GPL을 따르도록 강제하며,
그에 따라서 GPL 소스코드를 일부 차용하거나 수정한 결과물을 
판매하거나 배포할 경우에는 모든 소스코드를 공개해야 하는 의무가 있다.
그러나, 네트워크를 통해서 GPL 소스코드와 연결된 경우에는 GPL을 따를 의무가 "없다".
(물론, AGPL의 경우에는 네트워크를 통해서 연결된 경우에도  소스코드를 공개해야 하는 의무가 
있지만,  GHTS는 극히 일부분을 제외하고는 AGPL을 사용하지 않았다.)
(AGPL은 웹브라우저와 통신하면서 UI를 담당하는 부분만 적용됨.)
이로 인해서, 각자 자신만의 모듈을 별도의 프로그램으로 제작한 후,
GHTS와 네트워크로 메세지를 주고 받도록 하면 
자기의 모듈은 소스코드를 공개하지 않은 채, GPL V3의 GHTS를 이용할 수 있다.
물론, 자신의 모듈과의 상호작용을 위해서 GHTS "자체"에 수정을 가한 경우에는
수정된 부분의 소스코드도  GPL에 따라서 소스코드를 공개해야 한다.

그러므로, 공개하고 싶지 않은 자신만의 노하우, 로직, 전략등은 
독립된 모듈로 작성해서 GHTS와 메세지를 주고 받도록 하면 소스코드를 공개하지 않아도 되고,  
소스코드를 공개해도 괜찮은 부분만 GHTS에 포함 내지 수정한 후 GPL 의무규정에 따라서 
소스코드를 배포하면 된다.

어차피 무료로 공개할 거면서 왜 GPL 라이센스를 채택하여서 불편을 초래하였을까?
BSD, MIT, Apache등은 소스코드를 가져다가 마음대로 고쳐쓰고 판매해도 
아무런 제약 조건이 없고, 소스코드 공개 의무가 없어서 일견 더 좋아보인다.
그러나, 이럴 경우 소스코드를 공개하는 사람에게는 반대급부가 전혀 없으며,
소스코드를 공개하면 할 수록 경쟁자들을 도와주는 꼴만 된다.
그러나, GPL을 사용하면 자신이 공개한 소스코드 뿐만 아니라,
타인이 수정하거나 개선한 소스코드도 합쳐져서 사용할 수 있으므로,
자기가 경재자들을 도와주는 동시에,
경쟁자도 자신을 도와주는 게 된다.
즉, 일방적인 착취가 아닌 공동의 협력이 보장된다.
이로써, 개발에 참여하는 주체들 간에 교류와 협력이 활발해지고,
이로써 모든 사람들이 그 혜택을 입는다.
이렇게 공동 협력을 강제하는 시스템을 물질세계에 적용해서 성공하기는 쉽지 않지만,
소프트웨어 소스코드를 복제 및 배포하는 데 비용이 거의 들지 않는다는
특수성 때문에 프로젝트 규모가 크면 클 수록 GPL이 더 성공적인 경우가 많다.

실제로, 가장 거대한 소프트웨어 프로젝트 중의 하나인 리눅스 커널의 경우,
RedHat, SUSE등 전문 리눅스 업체 이외에도,
Intel, IBM, 삼성등 수많은 하드웨어 업체들,
Google, Facebook등 인터넷 업체들등이 참여하여 활발한 협업이 이루어지고 있다.
기업체들이 자신의 이익을 최대화 하기 위하여 인력과 자본을 투입하여 
소스코드를 개선하고 이러한 투자가 경쟁자들의 배만 불리는 것이 아니라,
 자기자신 또한 경쟁자들이 투자한 개선된 소스코드를 통해서 이득을 본다는 점 때문에,
 참여자가 많을 수록 자신의 이익이 커지는 시스템이 구축되었으며,
 이러한 시스템은 GPL 라이센스 때문에가능해졌다.
 
GHTS도 수익률 최대화와 시장에서 경쟁을 하는 시장참여자들이 
각자의 시간, 노력, 자본을 투자하여 개선한 소스코드를 공유하면서도,
경쟁자에게 일방적으로 이용만 당하지 않으면서 
경쟁자들이 투자에 의한 수혜도 입으면서 협력하여서 발전시켜 나가는 
시스템을 구성하고자 GPL을 채택하였다.
이렇게 모두가 공유하는 플랫폼의 경우 협력이 유리하지만,
매매전략의 경우 개별 매매전략에 투입되는 자본이 커질 수록
해당 전략의 수익률이 떨어지거나 아예 수익률이 사라지는 특성이 있다.
즉,  매매전략등은 협력하면 할 수록 불리한 특성이 있으며,
소스코드를 공개하지 않아야 할 필요가 있다.
그래서, GPL 기반의 GHTS 플랫폼은 공유하면서도 
자신만의 전략은 GPL에 해당되지 않고 소스코드를 공개하지 않는 것은
별도의 모듈로 개발하여 GHTS와는 네트워크를 통해서 통신하게 하면,
GPL의 소스코드 공개 의무에 적용되지 않는다.
네트워크로 사용하는 경우에도 소스코드 공개의무가 있는 AGPL은 
이러한 소스코드를 공개하지 않아야 할 필요성이 있는 부분에 대한
고려 때문에 일부러 채택하지 않았다.
